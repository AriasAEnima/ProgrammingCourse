===============================================================================
ğŸ­ GUIÃ“N COMPLETO - SESSION 5: SISTEMAS DISTRIBUIDOS (45 minutos)
===============================================================================

ğŸ“‹ PREREQUISITOS ANTES DE EMPEZAR:
- cd Chapter-Threads/Session5-DistributedSystems
- pip install -r requirements.txt
- Verificar que Projects funciona: cd ../Projects && python manage.py check

===============================================================================
â° MINUTOS 0-5: INTRODUCCIÃ“N Y CONEXIÃ“N (5 min)
===============================================================================

ğŸ¤ QUÃ‰ DECIR:
"Â¡Hola! Hemos estado viendo concurrencia y paralelismo EN una mÃ¡quina...
Threading, Multiprocessing, Async, IPC. Pero Â¿quÃ© pasa cuando necesitamos 
MÃšLTIPLES mÃ¡quinas trabajando juntas? Eso son los Sistemas Distribuidos."

"Piensen en Netflix, WhatsApp, Google... miles de servidores coordinÃ¡ndose."

ğŸ–¥ï¸ QUÃ‰ MOSTRAR (en slides o pizarra):
   Local (Sessions 1-5)    |  Distribuido (Session 6)
   ----------------------  |  -----------------------
   Memoria compartida      |  Solo comunicaciÃ³n por red
   Fallos = proceso crash  |  Fallos parciales
   Tiempo sincronizado     |  Cada mÃ¡quina su reloj
   threading.Lock          |  Distributed locks

ğŸ¤ QUÃ‰ DECIR:
"La evoluciÃ³n natural es:
- Queue           â†’ HTTP requests
- Pipe            â†’ REST APIs  
- Shared Memory   â†’ Distributed databases
- threading.Lock  â†’ Distributed locks"

"Pero aquÃ­ aparecen 3 desafÃ­os nuevos:
1. Sin memoria compartida â†’ Todo por red
2. Fallos parciales â†’ Una mÃ¡quina puede morir, otras siguen
3. Sin tiempo global â†’ DifÃ­cil coordinar eventos"

===============================================================================
â° MINUTOS 5-15: CONCEPTOS FUNDAMENTALES (10 min)
===============================================================================

ğŸ¤ QUÃ‰ DECIR:
"Vamos a ver esto en acciÃ³n. Tenemos nuestro servidor de imÃ¡genes 4K del 
proyecto anterior. Â¿CÃ³mo lo convertimos en un sistema distribuido?"

"En lugar de 1 servidor, vamos a tener 3 servidores trabajando juntos."

ğŸ–¥ï¸ QUÃ‰ MOSTRAR:
[Dibujar en pizarra o mostrar]

ANTES (proyecto anterior):
   Cliente â†’ [Servidor 8000] â†’ Respuesta

AHORA (Session 5):
           â”Œâ”€ [Servidor 8001] â”€â”€â”
   Cliente â†’ [Load Balancer]  â”€â”€ [Servidor 8002] â†’ Respuesta  
           â””â”€ [Servidor 8003] â”€â”€â”˜

ğŸ¤ QUÃ‰ DECIR:
"Los conceptos clave que vamos a ver son:

1. LOAD BALANCING: Distribuir requests entre servidores
2. FAULT TOLERANCE: Sistema sigue funcionando aunque fallen componentes  
3. HEALTH MONITORING: Supervisar estado de servidores
4. THREADING PARA HTTP: Requests paralelos a mÃºltiples servidores"

"Â¿Preguntas hasta aquÃ­? Â¿Todos entienden la diferencia entre local y distribuido?"

===============================================================================
â° MINUTOS 15-30: DEMO PRÃCTICA PROGRESIVA (15 min)
===============================================================================

ğŸ¤ QUÃ‰ DECIR:
"Â¡Manos a la obra! Vamos a distribuir nuestro servidor de imÃ¡genes paso a paso."

--- MINUTO 15-18: Setup de servidores (3 min) ---

ğŸ–¥ï¸ QUÃ‰ EJECUTAR:
python start_servers.py

ğŸ¤ QUÃ‰ DECIR MIENTRAS CARGA:
"Este script levanta 3 servidores Django automÃ¡ticamente en puertos 8001, 8002, 8003.
En producciÃ³n, estos estarÃ­an en mÃ¡quinas fÃ­sicas separadas."

[Esperar a que aparezca "âœ… Listo para demos!"]

ğŸ¤ QUÃ‰ DECIR:
"Â¡Perfecto! Tenemos 3 servidores funcionando. Ahora vamos a crear un 
load balancer para distribuir la carga."

--- MINUTO 18-25: Demo Load Balancer (7 min) ---

ğŸ–¥ï¸ QUÃ‰ EJECUTAR:
python distributor.py

ğŸ¤ QUÃ‰ DECIR:
"Primero veamos distribuciÃ³n bÃ¡sica con Round Robin."

ğŸ–¥ï¸ EN EL MENU: Elegir opciÃ³n 1

ğŸ¤ QUÃ‰ DECIR MIENTRAS CORRE:
"FÃ­jense que rota entre servidores: 8001 â†’ 8002 â†’ 8003 â†’ 8001...
Esto es Round Robin: distribuciÃ³n equitativa."

[Cuando termine el demo 1]

ğŸ¤ QUÃ‰ DECIR:
"Ahora probemos requests concurrentes usando Threading."

ğŸ–¥ï¸ EN EL MENU: Elegir opciÃ³n 2

ğŸ¤ QUÃ‰ DECIR MIENTRAS CORRE:
"Â¡Miren esto! ThreadPoolExecutor envÃ­a requests paralelos. 
Esto es threading aplicado a sistemas distribuidos."

[SeÃ±alar el throughput: "XXX requests/segundo"]

ğŸ¤ QUÃ‰ DECIR:
"Â¿Ven que threading sigue siendo Ãºtil en sistemas distribuidos?
Lo usamos para hacer requests HTTP paralelos."

--- MINUTO 25-30: Demo Fault Tolerance (5 min) ---

ğŸ¤ QUÃ‰ DECIR:
"Ahora viene lo interesante: Â¿quÃ© pasa si falla un servidor?"

ğŸ–¥ï¸ EN EL MENU: Elegir opciÃ³n 3

[Mientras ejecuta, abrir otra terminal]
ğŸ–¥ï¸ QUÃ‰ EJECUTAR EN OTRA TERMINAL:
ps aux | grep "manage.py runserver" | head -1 | awk '{print $2}' | xargs kill

ğŸ¤ QUÃ‰ DECIR:
"Acabo de 'matar' uno de los servidores para simular un fallo.
Â¡Pero el sistema sigue funcionando! Esto es tolerancia a fallos."

ğŸ–¥ï¸ EN EL MENU: Elegir opciÃ³n 4 (estadÃ­sticas)

ğŸ¤ QUÃ‰ DECIR:
"Las estadÃ­sticas muestran que algunos requests fallaron, pero el sistema
continÃºa operando. En producciÃ³n, siempre hay fallos parciales."

ğŸ–¥ï¸ EN EL MENU: Elegir opciÃ³n 0 (salir)

===============================================================================
â° MINUTOS 30-40: EJERCICIO HANDS-ON (10 min)
===============================================================================

ğŸ¤ QUÃ‰ DECIR:
"Â¡Ahora les toca a ustedes! Vamos a implementar un health monitor distribuido.
Van a usar threading para verificar servidores en paralelo."

ğŸ–¥ï¸ QUÃ‰ EJECUTAR:
python health_monitor.py

ğŸ¤ QUÃ‰ DECIR:
"Tienen 4 ejercicios progresivos:

1. Monitor secuencial (2 min) - BÃ¡sico
2. Monitor paralelo con threading (3 min) - MÃ¡s interesante  
3. Retry logic + Circuit breaker (4 min) - Avanzado
4. Monitoreo continuo (1 min) - Opcional

Empiecen por el ejercicio 1. Lean las pistas, implementen el cÃ³digo.
Â¡Pregunten si tienen dudas!"

--- MINUTOS 30-32: Ejercicio 1 ---
ğŸ¤ CIRCULAR ENTRE ESTUDIANTES:
"Â¿CÃ³mo van? Recuerden usar simple_health_check() y update_server_status()."
"El loop es: for server in SERVERS:"

--- MINUTOS 32-35: Ejercicio 2 ---  
ğŸ¤ QUÃ‰ DECIR:
"Pasen al ejercicio 2. AquÃ­ usan ThreadPoolExecutor.
Â¿Recuerdan cÃ³mo se usa? from concurrent.futures import ThreadPoolExecutor"

ğŸ¤ AYUDAR SI SE ATORAN:
"La estructura es:
with ThreadPoolExecutor(max_workers=5) as executor:
    futures = [executor.submit(funciÃ³n, server) for server in SERVERS]"

--- MINUTOS 35-39: Ejercicio 3 ---
ğŸ¤ QUÃ‰ DECIR:
"Los que terminaron el 2, pasen al 3. Implementen retry logic.
Si un servidor falla 3 veces seguidas, mÃ¡rquenlo como 'CIRCUIT_OPEN'."

--- MINUTO 39-40: Ejercicio 4 ---
ğŸ¤ QUÃ‰ DECIR:
"El 4 es opcional. Es monitoreo continuo con threading."

===============================================================================
â° MINUTOS 40-45: WRAP-UP Y SIGUIENTES PASOS (5 min)
===============================================================================

ğŸ¤ QUÃ‰ DECIR:
"Â¡Excelente trabajo! Vamos a cerrar con los conceptos clave."

ğŸ–¥ï¸ QUÃ‰ MOSTRAR (pizarra o slides):

EVOLUCIÃ“N COMPLETA:
   Session 1:   Threading/Concurrency      â†’  Una mÃ¡quina
   Session 2:   Multiprocessing/Parallelism â†’  Una mÃ¡quina  
   Session 3:   Async/await               â†’  Una mÃ¡quina
   Session 4:   IPC (Pipes/Queues)       â†’  Una mÃ¡quina
   Session 5:   Sistemas Distribuidos    â†’  MÃšLTIPLES mÃ¡quinas

ğŸ¤ QUÃ‰ DECIR:
"Â¿QuÃ© aprendimos hoy?

âœ… LOAD BALANCING: Distribuir carga entre servidores
âœ… THREADING PARA HTTP: Requests paralelos siguen siendo Ãºtiles
âœ… FAULT TOLERANCE: Sistema robusto ante fallos  
âœ… HEALTH MONITORING: SupervisiÃ³n automÃ¡tica

Â¿Ven cÃ³mo threading sigue siendo relevante en sistemas distribuidos?
Lo usamos para hacer requests HTTP en paralelo."

ğŸ¤ QUÃ‰ DECIR:
"SIGUIENTES PASOS en el mundo real:

- Message Queues: Redis, RabbitMQ para comunicaciÃ³n asÃ­ncrona
- Container Orchestration: Docker + Kubernetes para escalar
- Microservices: Arquitectura de servicios independientes  
- Monitoring: Prometheus + Grafana para observabilidad"

ğŸ¤ QUÃ‰ DECIR:
"PREGUNTA FINAL: Â¿CuÃ¡l es la diferencia mÃ¡s importante entre 
programaciÃ³n local y sistemas distribuidos?"

[Esperar respuestas: "Fallos parciales", "Sin memoria compartida", etc.]

ğŸ¤ QUÃ‰ DECIR:
"Â¡Exacto! En local, si algo falla, TODO falla. En distribuido, 
partes pueden fallar pero el sistema sigue funcionando."

"Â¿Preguntas? Â¿Algo que no quedÃ³ claro?"

===============================================================================
ğŸ§¹ CLEANUP AL FINAL:
===============================================================================

ğŸ–¥ï¸ QUÃ‰ EJECUTAR (si los procesos siguen corriendo):
ps aux | grep "manage.py runserver" | awk '{print $2}' | xargs kill

ğŸ¤ QUÃ‰ DECIR:
"Â¡Excelente sesiÃ³n! Tienen todo el cÃ³digo en Session5-DistributedSystems
para experimentar mÃ¡s. Â¡Ahora van a trabajar en su proyecto durante la semana!"

===============================================================================
ğŸ“ NOTAS PARA EL INSTRUCTOR:
===============================================================================

TIMING CRÃTICO:
- Demo prÃ¡ctica: MAX 15 minutos (no extenderse)
- Ejercicios: Asegurar que al menos hagan ejercicio 1 y 2
- Si van lentos: Saltar ejercicio 3 y 4

ENGAGEMENT TIPS:
- Preguntar constantemente: "Â¿QuÃ© creen que pasa si...?"
- Conectar con conocimiento previo: "Esto es como threading, pero..."
- Matar servidor durante demo para mostrar fallos en vivo

TROUBLESHOOTING:
- Si distributor.py no encuentra servidores: Verificar puertos con lsof -i :8001
- Si students se atoran en ejercicios: Mostrar las soluciones comentadas
- Si no hay tiempo: Ejecutar demo_complete.py en lugar de demos manuales

CONCEPTOS CLAVE A ENFATIZAR:
1. Threading sigue siendo Ãºtil (para HTTP requests)
2. Fallos parciales son la nueva realidad  
3. Load balancing es esencial
4. Monitoring es crÃ­tico

=============================================================================== 